📋 公式な方法の詳細解説

  1. システム構成（データフロー）

  ┌─────────────────────────────────────────────────────────────────┐
  │                         PC側（Linux/Windows）                      │
  │  ┌──────────────────────────────────────────────────────────┐  │
  │  │          RobotVisionConsole プログラム                    │  │
  │  │                                                            │  │
  │  │  1️⃣ ZED Mini カメラ                                       │  │
  │  │     └─> sl::Camera (ZED SDK)                             │  │
  │  │     └─> SIDE_BY_SIDE モードで撮影                         │  │
  │  │         (左右のステレオ画像を横に並べる)                   │  │
  │  │         解像度: 2560x720 (1280x720 × 2)                   │  │
  │  │                                                            │  │
  │  │  2️⃣ 画像変換                                              │  │
  │  │     └─> RGBA → YUV420p                                    │  │
  │  │                                                            │  │
  │  │  3️⃣ H.264 エンコード                                      │  │
  │  │     └─> H264Encoder (FFmpeg)                              │  │
  │  │     └─> ビットレート: 12Mbps (設定可能)                   │  │
  │  │     └─> フレームレート: 60fps (設定可能)                  │  │
  │  │                                                            │  │
  │  │  4️⃣ ネットワーク送信                                       │  │
  │  │     └─> CameraDataSender (ASIO/TCP)                       │  │
  │  │     └─> パケット形式:                                      │  │
  │  │         [4バイト長さ][H.264 NALU データ]                  │  │
  │  │         (ビッグエンディアン)                               │  │
  │  └──────────────────────────────────────────────────────────┘  │
  │                           │                                       │
  │                           │ TCP (デフォルト: port 12345)          │
  │                           ▼                                       │
  └─────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────┐
  │                      Pico VR側（Android）                         │
  │  ┌──────────────────────────────────────────────────────────┐  │
  │  │       XRoboToolkit Unity Client APP                       │  │
  │  │                                                            │  │
  │  │  1️⃣ TCP受信                                               │  │
  │  │     └─> ポート 12345 で待機                                │  │
  │  │     └─> 設定読み込み: pico_video_source_actual.yml       │  │
  │  │                                                            │  │
  │  │  2️⃣ H.264 デコード                                        │  │
  │  │     └─> Unity の VideoPlayer または MediaCodec            │  │
  │  │                                                            │  │
  │  │  3️⃣ VR表示                                                │  │
  │  │     └─> ステレオ映像を左右の目に分割表示                  │  │
  │  │     └─> シェーダー処理（歪み補正など）                     │  │
  │  └──────────────────────────────────────────────────────────┘  │
  └─────────────────────────────────────────────────────────────────┘

  2. コードの処理フロー（main.cpp:516-665）

  // 1. TCP接続の確立
  CameraDataSender sender(server_ip, port);  // 例: "192.168.1.100", 12345

  // 2. H.264エンコーダー初期化
  H264Encoder h264_encoder(
      resolution_width * 2,  // 幅は2倍（SIDE_BY_SIDE）
      resolution_height,      // 720
      encoder_callback,       // エンコード後のコールバック
      frameRate,             // 60fps
      bitrate                // 12000000 bps (12Mbps)
  );

  // 3. ZED カメラ初期化
  sl::Camera zed;
  zed.open(init_parameters);

  // 4. メインループ
  while (continue_capture) {
      // ステレオ画像を取得（左右並べて）
      zed.retrieveImage(zed_image, sl::VIEW::SIDE_BY_SIDE);

      // RGBA → YUV420p 変換
      convertRBGAToYUV(zed_image, y_plane, u_plane, v_plane);

      // H.264エンコード + TCP送信
      h264_encoder.encodeFrame(y_plane, u_plane, v_plane);
  }

  3. 「ビルドが必要」とは？

  ビルド（Build）= ソースコードから実行可能プログラムを生成する作業

  現在の状態:

  XRoboToolkit-RobotVision-PC/
  ├── src/              ← C++ソースコード（.cpp, .h）
  │   ├── H264Encoder.cpp
  │   ├── CameraDataSender.cpp
  │   └── ...
  └── RobotVisionTest/
      ├── main.cpp      ← メインプログラム
      └── Makefile.orin ← ビルド手順書

  ❌ 実行ファイル（RobotVisionConsole）がない
  ✅ ソースコードだけがある

  ビルドの必要性:

  | 項目     | Python (zed_camera_server.py) | C++ (RobotVisionConsole)          |
  |----------|-------------------------------|-----------------------------------|
  | 現状     | ✅ すぐに実行可能             | ❌ ビルドが必要                   |
  | 理由     | Pythonは解釈型言語            | C++はコンパイル型言語             |
  | 実行方法 | python3 zed_camera_server.py  | まずビルド → ./RobotVisionConsole |

  4. ビルド手順（Makefile.orinを使用）

  必要な依存関係:

  # 1. ZED SDK
  - libsl_zed.so
  - /usr/local/zed/include

  # 2. FFmpeg
  - libavcodec, libavformat, libavutil, libswscale, libavdevice

  # 3. CUDA
  - libcuda, libcudart
  - /usr/local/cuda/lib64

  # 4. OpenCV
  - libopencv_core, libopencv_imgproc, libopencv_videoio

  # 5. ASIO（ネットワークライブラリ）
  - ../../asio-1.30.2/include

  ビルドコマンド:

  cd /home/kota-ueda/TWIST2/XRoboToolkit-RobotVision-PC/VideoTransferPC/RobotVisionTest

  # ビルド実行
  make -f Makefile.orin

  # 成功すると生成される
  # → RobotVisionConsole (実行可能ファイル)

  ビルドで行われること（Makefile.orin）:

  1. コンパイル（.cpp → .o）:
  g++ -std=c++17 -I/usr/local/zed/include ... -c main.cpp -o main.o
  2. リンク（.o → 実行ファイル）:
  g++ -o RobotVisionConsole main.o ... -lsl_zed -lavcodec -lavformat ...

  5. 設定ファイルの役割

  PC側（設定不要）:

  コマンドライン引数で全て指定
  RobotVisionConsole --tcp-camera c \
    --ip 192.168.1.100 \        # Pico VRのIPアドレス
    --port 12345 \
    --width 1280 \               # 片目の幅（実際は2560になる）
    --height 720 \
    --fps 60 \
    --bitrate 12000000

  Pico側（pico_video_source_actual.yml）:

  - name: "ZEDMINI"
    camera: "ZED"
    properties:
      - name: "CamWidth"
        value: 2560        # SIDE_BY_SIDEの幅
      - name: "CamHeight"
        value: 720
      - name: "CamFPS"
        value: 60
      - name: "CamBitrate"
        value: 12000000    # 12Mbps

  6. なぜ2つの方法があるのか？

  | 項目         | RobotVisionConsole (C++)  | zed_camera_server.py (Python) |
  |--------------|---------------------------|-------------------------------|
  | 形式         | H.264（動画圧縮）         | JPEG（静止画圧縮）            |
  | 圧縮率       | 高効率（12Mbps で高画質） | 低効率（帯域幅が大きい）      |
  | 遅延         | 低い                      | やや高い                      |
  | CPU負荷      | GPU利用可能               | CPU のみ                      |
  | ステレオ     | ✅ SIDE_BY_SIDE対応       | ❓ 片目のみ？                 |
  | セットアップ | 複雑（ビルド必要）        | 簡単（すぐ実行可能）          |
  | Pico対応     | ✅ 公式対応               | ❓ 非公式？                   |

  → RobotVisionConsoleが本来の公式な方法、zed_camera_server.pyはテスト/デバッグ用の代替手段

  まとめると、ビルド = ソースコードを実行可能な形に変換する作業で、C++プログラムを実行するには必須の工程です。

  🎉 完全に成功しました！

  ✅ Linuxでビルド・実行可能です

  ビルド結果

  ✅ ビルド成功
  ✅ 実行ファイル生成: RobotVisionConsole (4.1 MB)
  ✅ 動作確認: 正常にヘルプメッセージを表示

  システム要件（すべて満たしています）

  | 依存関係       | ステータス | バージョン/場所                                             |
  |----------------|------------|-------------------------------------------------------------|
  | g++ コンパイラ | ✅         | 11.4.0                                                      |
  | ZED SDK        | ✅         | /usr/local/zed/lib/libsl_zed.so                             |
  | FFmpeg         | ✅         | libavcodec, libavformat, libavutil, libswscale, libavdevice |
  | CUDA           | ✅         | /usr/local/cuda/lib64/                                      |
  | OpenCV         | ✅         | 4.5.4                                                       |
  | ASIO           | ✅         | ../../asio-1.30.2/include/asio.hpp                          |

  ビルド手順のまとめ

  # 1. ディレクトリ移動
  cd /home/kota-ueda/TWIST2/XRoboToolkit-RobotVision-PC/VideoTransferPC/RobotVisionTest

  # 2. ビルド
  make -f Makefile.orin

  # 3. 実行ファイルが生成される
  # → RobotVisionConsole (4.1 MB)

  # 4. 使い方を確認
  ./RobotVisionConsole

  実際の使用例（ZED Mini → Pico VR）

  # Pico VRのIPアドレスを確認（例: 192.168.1.100）

  # PC側でRobotVisionConsoleを起動
  ./RobotVisionConsole --tcp-camera c \
    --ip 192.168.1.100 \      # Pico VRのIPアドレス
    --port 12345 \
    --width 1280 \             # 片目の幅（SIDE_BY_SIDEで2560になる）
    --height 720 \
    --fps 60 \
    --bitrate 12000000         # 12 Mbps

  📝 SYSTEM_OVERVIEW.mdの情報について

  SYSTEM_OVERVIEW.mdには「❌ Linuxでビルド不可」と記載されていましたが、実際には：

  - ✅ Makefile.orinが用意されている
  - ✅ クロスプラットフォーム対応コード（#ifdef _WIN32）
  - ✅ すべての依存関係が揃っている
  - ✅ ビルド・実行成功

  → 過去の記録が古いか、試していなかった可能性があります

  次のステップ

  1. Pico VR側のセットアップ
    - XRoboToolkit Unity Client APPをインストール
    - https://github.com/XR-Robotics/XRoboToolkit-Unity-Client/releases/
  2. 設定ファイルの配置
    - pico_video_source_actual.ymlをPico側に配置（詳細はアプリのドキュメント参照）
  3. 実行
    - Pico側でアプリを起動、ZEDMINIプロファイルを選択、Listen
    - PC側でRobotVisionConsoleを起動

  結論: LinuxでもRobotVisionConsoleは完全にビルド・使用可能です！ 🚀

 初心者向け完全ガイド

  1. なぜ「Linuxでビルド不可」と判断したのか

  当時あなたが見つけた証拠：

  | 証拠                      | あなたの判断                        | 実際の真実                       |
  |---------------------------|-------------------------------------|----------------------------------|
  | build_release.batファイル | 「Windowsのバッチファイルしかない」 | ✅ 正しいが、Makefile.orinも存在 |
  | #include <windows.h>      | 「Windows専用のヘッダーが必要」     | ❌ #ifdef _WIN32で条件分岐済み   |
  | CMakeLists.txtのif(WIN32) | 「Windows専用のビルド設定」         | ❌ クロスプラットフォーム対応    |
  | README.mdの内容           | 「Visual Studio 2019が必要」        | ✅ Windowsの場合のみ             |

  コードで確認：

  // main.cpp:34-82 の実際のコード

  #ifdef _WIN32
  // ↓ Windowsの場合だけ実行される
  #include <conio.h>
  #include <windows.h>
  #else
  // ↓ Linux/macOSの場合はこちら（代替実装がある）
  #include <termios.h>
  #include <unistd.h>
  #include <fcntl.h>

  #define OutputDebugStringA(x) std::cerr << x
  // Linux用のキーボード入力関数も実装されている
  int _kbhit() { /* Linux実装 */ }
  int _getch() { /* Linux実装 */ }
  #endif

  → つまり、windows.hはLinuxでは使われない！

  ---
  2. ビルドができるかどうかの要件とは？

  🎯 ビルドの定義（超初心者向け）

  ビルド = 人間が読めるコードを、コンピュータが実行できる形に変換する作業

  人間が書いたコード        ビルド        コンピュータが実行できる形
      (main.cpp)      ────────►      (RobotVisionConsole)
       テキスト                        バイナリ（実行ファイル）

  📋 ビルドに必要な3つの要素

  ① ビルドツール（コードを変換する道具）

  | ツール         | 用途                              | Linux              | Windows                    |
  |----------------|-----------------------------------|--------------------|----------------------------|
  | コンパイラ     | .cpp → .o（オブジェクトファイル） | g++                | MSVC (Visual Studio)       |
  | リンカー       | .o → 実行ファイル                 | ld (g++に含まれる) | MSVC                       |
  | ビルドシステム | ビルド手順を自動化                | Make または CMake  | CMake または Visual Studio |

  あなたのシステム:
  ✅ g++ 11.4.0        # コンパイラ
  ✅ Make              # ビルドシステム
  ✅ Makefile.orin     # ビルド手順書

  ② 依存ライブラリ（コードが使っている部品）

  main.cppが使っているライブラリ：

  #include <sl/Camera.hpp>        // ← ZED SDK が必要
  #include <libavcodec/avcodec.h> // ← FFmpeg が必要
  #include <opencv2/opencv.hpp>   // ← OpenCV が必要
  #include <asio.hpp>             // ← ASIO が必要
  #include <cuda_runtime.h>       // ← CUDA が必要

  あなたのシステム:
  ✅ ZED SDK     (/usr/local/zed/lib/libsl_zed.so)
  ✅ FFmpeg      (libavcodec, libavformat, ...)
  ✅ OpenCV 4.5.4
  ✅ CUDA        (/usr/local/cuda/lib64/)
  ✅ ASIO 1.30.2 (../../asio-1.30.2/include/)

  すべて揃っている = ビルド可能！

  ③ プラットフォーム対応コード

  コードがLinuxでも動作するように書かれているか？

  // ❌ Windows専用コード（Linuxでビルド不可）
  #include <windows.h>
  MessageBox(NULL, "Hello", "Title", MB_OK);

  // ✅ クロスプラットフォーム対応コード
  #ifdef _WIN32
      #include <windows.h>
      MessageBox(NULL, "Hello", "Title", MB_OK);
  #else
      std::cout << "Hello" << std::endl;
  #endif

  main.cppはクロスプラットフォーム対応済み！

  ---
  3. ビルドの流れ（実際に何が起こったか）

  ステップバイステップ

  $ make -f Makefile.orin

  ステップ1: コンパイル（.cpp → .o）
  g++ -c main.cpp -o main.o
  # main.cpp（テキスト）を機械語（main.o）に変換

  ステップ2: コンパイル（他のファイルも）
  g++ -c ../src/H264Encoder.cpp -o ../src/H264Encoder.o
  g++ -c ../src/H264Decoder.cpp -o ../src/H264Decoder.o
  ...

  ステップ3: リンク（.o + ライブラリ → 実行ファイル）
  g++ -o RobotVisionConsole \
      main.o \
      H264Encoder.o \
      ... \
      -lsl_zed \      # ZED SDKライブラリをリンク
      -lavcodec \     # FFmpegライブラリをリンク
      -lopencv_core   # OpenCVライブラリをリンク

  結果:
  ✅ RobotVisionConsole (4.1 MB) 生成完了

  ---
  4. まとめ：あなたの質問への回答

  Q1: なぜ当時「Linuxでビルド不可」と判断したのか？

  A: 以下の理由から：
  1. ✅ README.mdがWindows中心だった
  2. ✅ windows.hを見つけた（条件分岐に気づかなかった）
  3. ✅ Makefile.orinを見落としたか、試さなかった
  4. ✅ CMakeLists.txtがWindows設定に見えた

  → 判断は合理的だったが、詳細調査が不足していた

  Q2: ビルドができるかどうかの要件とは？

  A: 3つの要件：
  1. ✅ ビルドツール（g++, Make, CMakeなど）
  2. ✅ 依存ライブラリ（ZED SDK, FFmpeg, OpenCV, CUDA, ASIO）
  3. ✅ プラットフォーム対応コード（#ifdef _WIN32など）

  → すべて満たしている = ビルド可能

  Q3: ビルドできてしまったという認識でいいか？

  A: はい！完全にビルド成功しました。

  ✅ ビルド完了
  ✅ 実行ファイル生成: RobotVisionConsole (4.1 MB)
  ✅ 正常に起動確認済み

  Q4: これを使えばZED MiniからPicoに映像を伝えられるか？

  A: はい、理論的には可能です。

  PC (Linux)                               Pico VR
  ┌─────────────────────┐                 ┌──────────────────┐
  │ RobotVisionConsole  │  TCP/IP         │ XRoboToolkit APP │
  │                     │ ──────────────► │                  │
  │ ZED Mini → H.264    │  port 12345     │ H.264 → 表示     │
  └─────────────────────┘                 └──────────────────┘

  ただし、VIDEO_STREAMING_DEBUG_REPORT.mdによると：
  - ✅ PC側（OrinVideoSender）は正常動作
  - ❌ Pico側（Unity Client v1.1.0）が受信できていない

  → RobotVisionConsoleも同じ問題に遭遇する可能性がある
  → Pico側のアプリやバージョンの問題かもしれない

  ---
  5. 次のステップ

  試すべきこと：

  # 1. RobotVisionConsoleで実際に送信してみる
  ./RobotVisionConsole --tcp-camera c \
    --ip <Pico_IP> \
    --port 12345 \
    --width 1280 \
    --height 720 \
    --fps 60 \
    --bitrate 12000000

  # 2. Pico側でXRoboToolkit APPを起動
  #    - ZEDMINIプロファイルを選択
  #    - Listenをクリック

  # 3. 接続確認
  #    - PC側: "Connection succeeded"
  #    - Pico側: 白い画面 → 失敗、映像表示 → 成功

  成功の可能性: 中〜高
  - ✅ 公式プログラムを使用
  - ✅ H.264エンコードが正しい
  - ❓ Pico側の問題が解決されるかは不明
